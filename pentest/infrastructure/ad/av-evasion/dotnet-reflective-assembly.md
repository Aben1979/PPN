# .NET Reflective Assembly

* [https://github.com/S3cur3Th1sSh1t/PowerSharpPack#powersharppack](https://github.com/S3cur3Th1sSh1t/PowerSharpPack#powersharppack)
* [https://github.com/GhostPack/Rubeus#sidenote-running-rubeus-through-powershell](https://github.com/GhostPack/Rubeus#sidenote-running-rubeus-through-powershell)
* [https://github.com/cfalta/PowerShellArmoury/blob/master/ConvertTo-Powershell.ps1](https://github.com/cfalta/PowerShellArmoury/blob/master/ConvertTo-Powershell.ps1)
* [https://github.com/LuemmelSec/Pentest-Tools-Collection/blob/main/tools/convert_c%23_to_ps1.ps1](https://github.com/LuemmelSec/Pentest-Tools-Collection/blob/main/tools/convert_c%23_to_ps1.ps1)

A way to bypass AV signature analysis: you can Gzip-compress and Base64-encode a .NET assembly to load it reflectively via PowerShell right from memory (when compiling the binary, make `Program` class and its `Main` method public):

{% code title="CompressEncodeAssembly.ps1" %}
```powershell
$bytes = [System.IO.File]::ReadAllBytes("\path\to\binary.exe")
[System.IO.MemoryStream] $output = New-Object System.IO.MemoryStream
$gzipStream = New-Object System.IO.Compression.GzipStream($output, [System.IO.Compression.CompressionMode]::Compress)
$gzipStream.Write($bytes, 0, $bytes.Length)
$gzipStream.Close()
$output.Close()
[byte[]] $byteOutArray = $output.ToArray()
$encodedZipped = [System.Convert]::ToBase64String($byteOutArray)
$encodedZipped
```
{% endcode %}

This [blog post](https://www.praetorian.com/blog/running-a-net-assembly-in-memory-with-meterpreter) covers the topic in depth. Also here is [an example](https://github.com/snovvcrash/PowerSharpPack/blob/master/PowerSharpBinaries/Invoke-SharpMapExec.ps1) how the binary can be actually decoded, decompressed and run from memory.
